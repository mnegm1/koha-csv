<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Koha ODS Chatbot</title>

  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#BF9849;padding:2rem}
    .fab{position:fixed;right:18px;bottom:18px;background:#3EA3DC;color:#fff;border:none;border-radius:50%;
         width:56px;height:56px;font-size:24px;cursor:pointer;box-shadow:0 8px 20px rgba(0,0,0,.25);z-index:9999}
    .box{position:fixed;right:18px;bottom:86px;width:min(520px,92vw);max-height:70vh;background:#fff;border-radius:14px;
         border:1px solid #e8eef3;box-shadow:0 16px 40px rgba(0,0,0,.25);display:flex;flex-direction:column;overflow:hidden;z-index:9999}
    .head{background:#BF9849;color:#fff;padding:10px 14px;font-weight:600;display:flex;justify-content:space-between}
    .body{padding:10px;overflow:auto;max-height:56vh;font-size:14px}
    .row{background:#f6f9fc;border:1px solid #e7edf4;border-radius:12px;padding:12px;margin:10px 0}
    .meta{opacity:.85;font-size:12px;margin-top:6px}
    .input{display:flex;gap:8px;padding:10px;background:#fafafa;border-top:1px solid #e8eef3}
    .input input{flex:1;padding:10px;border-radius:10px;border:1px solid #cfd9e3}
    .input button{background:#BF9849;color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:600}
    .error{background:#fff0f0;border:1px solid #f5b5b5;color:#900;padding:10px}
    .btn{flex:0 0 auto;background:#BF9849;color:#fff;padding:6px 10px;border-radius:8px;text-decoration:none;font-weight:600}
  </style>

  <!-- SheetJS loader (tries local copy first, then CDNs) -->
  <script>
  (function loadSheetJS(){
    const sources = [
      "/koha-csv/xlsx.full.min.js",
      "https://mnegm1.github.io/koha-csv/xlsx.full.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.20.3/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.20.3/dist/xlsx.full.min.js",
      "https://unpkg.com/xlsx@0.20.3/dist/xlsx.full.min.js"
    ];
    let i = 0;
    function tryNext(){
      if (i >= sources.length) { window.__XLSX_LOAD_ERROR__ = "All sources failed"; return; }
      const s = document.createElement("script");
      s.src = sources[i++]; s.async = true;
      s.onload  = () => { window.__XLSX_READY__ = true; };
      s.onerror = tryNext;
      document.head.appendChild(s);
    }
    tryNext();
  })();
  </script>
</head>
<body>
  <h2>Koha ODS Chatbot</h2>
  <p>This page loads the ODS catalog and adds the chat bubble üí¨ automatically.</p>

  <script>
  (function startWhenReady(){
    if (window.__XLSX_LOAD_ERROR__) {
      const pre = document.createElement("div");
      pre.className = "error";
      pre.textContent = "Failed to load XLSX library.";
      document.body.appendChild(pre);
      return;
    }
    if (!window.__XLSX_READY__) return setTimeout(startWhenReady, 150);

    /* ===== CONFIG ===== */
    const BOT_CFG = {
      DATA_URL: "https://raw.githubusercontent.com/mnegm1/koha-csv/main/opac-catalog.ods",
      MAX_RESULTS: 8,
      MIN_QUERY_LEN: 2
    };

    /* ===== UI ===== */
    const fab=document.createElement("button"); fab.className="fab"; fab.textContent="üí¨";
    const box=document.createElement("div"); box.className="box";
    box.innerHTML=`
      <div class="head">
        <div>Catalog Assistant</div>
        <button id="x" style="background:none;border:none;color:#fff;font-size:18px;cursor:pointer">√ó</button>
      </div>
      <div class="body" id="body">
        <div class="row" id="status">Loading catalog‚Ä¶</div>
        <div class="row">Type title, author, year, ÿ£Ÿà ŸÉŸÑŸÖÿßÿ™ ŸÖŸÜ ÿßŸÑŸÖŸÑÿÆÿµ/ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ. ŸÅŸÑÿßÿ™ÿ±: author:"name"  year:2021</div>
      </div>
      <div class="input">
        <input id="q" type="text" placeholder="Search / ÿßÿ®ÿ≠ÿ´" dir="auto">
        <button id="go">Search</button>
      </div>`;
    document.body.appendChild(fab); document.body.appendChild(box);
    const B = box.querySelector("#body"), Q = box.querySelector("#q"), GO = box.querySelector("#go");
    fab.onclick = () => box.style.display = (box.style.display==="flex" ? "none" : "flex");
    box.style.display = "flex"; Q.focus();

  /* ===== Unicode-aware Arabic detection + tokenization ===== */

// Use Unicode property escapes instead of manual ranges
const U_LETTER_OR_NUMBER_RE = /[\p{L}\p{N}]+/gu;              // tokens = all letters/numbers from any script
const U_ARABIC_ANY_RE       = /\p{Script=Arabic}/u;           // ‚Äúdoes this string contain Arabic?‚Äù

function isArabic(s){ return U_ARABIC_ANY_RE.test(String(s||"")); }

// Normalize Arabic presentation forms + common variants (keep your existing map)
function normalizeArabicForms(str){
  if(!str) return "";
  const map = {
    'Ô∫ç':'ÿß','Ô∫é':'ÿß','Ô∫É':'ÿß','Ô∫Ñ':'ÿß','Ô∫á':'ÿß','Ô∫à':'ÿß','Ÿ±':'ÿß',
    'Ô∫è':'ÿ®','Ô∫ê':'ÿ®','Ô∫ë':'ÿ®','Ô∫í':'ÿ®',
    'Ô∫ï':'ÿ™','Ô∫ñ':'ÿ™','Ô∫ó':'ÿ™','Ô∫ò':'ÿ™',
    'Ô∫ô':'ÿ´','Ô∫ö':'ÿ´','Ô∫õ':'ÿ´','Ô∫ú':'ÿ´',
    'Ô∫ù':'ÿ¨','Ô∫û':'ÿ¨','Ô∫ü':'ÿ¨','Ô∫†':'ÿ¨',
    'Ô∫°':'ÿ≠','Ô∫¢':'ÿ≠','Ô∫£':'ÿ≠','Ô∫§':'ÿ≠',
    'Ô∫•':'ÿÆ','Ô∫¶':'ÿÆ','Ô∫ß':'ÿÆ','Ô∫®':'ÿÆ',
    'Ô∫©':'ÿØ','Ô∫™':'ÿØ','Ô∫´':'ÿ∞','Ô∫¨':'ÿ∞',
    'Ô∫≠':'ÿ±','Ô∫Æ':'ÿ±','Ô∫Ø':'ÿ≤','Ô∫∞':'ÿ≤',
    'Ô∫±':'ÿ≥','Ô∫≤':'ÿ≥','Ô∫≥':'ÿ≥','Ô∫¥':'ÿ≥',
    'Ô∫µ':'ÿ¥','Ô∫∂':'ÿ¥','Ô∫∑':'ÿ¥','Ô∫∏':'ÿ¥',
    'Ô∫π':'ÿµ','Ô∫∫':'ÿµ','Ô∫ª':'ÿµ','Ô∫º':'ÿµ',
    'Ô∫Ω':'ÿ∂','Ô∫æ':'ÿ∂','Ô∫ø':'ÿ∂','ÔªÄ':'ÿ∂',
    'ÔªÅ':'ÿ∑','ÔªÇ':'ÿ∑','ÔªÉ':'ÿ∑','ÔªÑ':'ÿ∑',
    'ÔªÖ':'ÿ∏','ÔªÜ':'ÿ∏','Ôªá':'ÿ∏','Ôªà':'ÿ∏',
    'Ôªâ':'ÿπ','Ôªä':'ÿπ','Ôªã':'ÿπ','Ôªå':'ÿπ',
    'Ôªç':'ÿ∫','Ôªé':'ÿ∫','Ôªè':'ÿ∫','Ôªê':'ÿ∫',
    'Ôªë':'ŸÅ','Ôªí':'ŸÅ','Ôªì':'ŸÅ','Ôªî':'ŸÅ',
    'Ôªï':'ŸÇ','Ôªñ':'ŸÇ','Ôªó':'ŸÇ','Ôªò':'ŸÇ',
    'Ôªô':'ŸÉ','Ôªö':'ŸÉ','Ôªõ':'ŸÉ','Ôªú':'ŸÉ',
    'Ôªù':'ŸÑ','Ôªû':'ŸÑ','Ôªü':'ŸÑ','Ôª†':'ŸÑ',
    'Ôª°':'ŸÖ','Ôª¢':'ŸÖ','Ôª£':'ŸÖ','Ôª§':'ŸÖ',
    'Ôª•':'ŸÜ','Ôª¶':'ŸÜ','Ôªß':'ŸÜ','Ôª®':'ŸÜ',
    'Ôª©':'Ÿá','Ôª™':'Ÿá','Ôª´':'Ÿá','Ôª¨':'Ÿá',
    'Ôª≠':'Ÿà','ÔªÆ':'Ÿà',
    'Ôª±':'Ÿä','Ôª≤':'Ÿä','Ôª≥':'Ÿä','Ôª¥':'Ÿä','Ôª∞':'Ÿâ',
    'Ôªª':'ŸÑÿß','Ôªº':'ŸÑÿß'
  };
  return str.replace(/[\uFE70-\uFEFF\uFB50-\uFDFF]/g, ch => map[ch] || ch);
}

// Canonical normalizer (kept from your code, but works with any script)
function norm(s){
  if (!s) return "";
  let t = String(s).toLowerCase()
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, ""); // strip Latin diacritics
  t = normalizeArabicForms(t);
  t = t
    // Arabic: strip tashkƒ´l + tatweel
    .replace(/[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED\u0640]/g,"")
    // strip zero-width + bidi marks
    .replace(/[\u200c-\u200f\u202a-\u202e]/g,"")
    // unification forms
    .replace(/[ÿ•ÿ£ÿ¢Ÿ±]/g,"ÿß").replace(/[Ÿâ€å]/g,"Ÿä").replace(/⁄©/g,"ŸÉ");
  return t;
}

// Tokenizer: grab all letter/number runs across scripts, then normalize each
function toks(s){
  const out = [];
  const src = String(s ?? "");
  const it = src.matchAll(U_LETTER_OR_NUMBER_RE);
  for (const m of it) {
    const t = norm(m[0]);
    if (t) out.push(t);
  }
  return out;
}

/* ===== Stopwords (normalize once so they match normalized tokens) ===== */
const RAW_STOP = new Set([
  "the","and","of","in","on","for","a","an","to","with","by",
  "ÿπŸÜ","ŸÅŸä","ÿπŸÑŸâ","ŸÖŸÜ","Ÿà","ÿßŸÑŸâ"
]);
const STOP = new Set(Array.from(RAW_STOP, w => norm(w)));

/* ===== Make fallback use the same tokenizer ===== */
function fallbackScan(idx, q, limit){
  const terms = toks(q);
  if (!terms.length) return [];
  const out = [];
  for (const rec of idx){
    const hay = rec.n.all; // already normalized
    if (terms.every(t => hay.includes(t))){
      out.push({sc:1, rec});
      if (out.length >= (limit || BOT_CFG.MAX_RESULTS)) break;
    }
  }
  return out;
}

    /* ===== Ranking / search ===== */
    const WEIGHTS={title:4,author:3,summary:1.5,content:1.5,publisher:1,year:2};
    const STOP=new Set(["the","and","of","in","on","for","a","an","to","with","by","ÿπŸÜ","ŸÅŸä","ÿπŸÑŸâ","ŸÖŸÜ","Ÿà","ÿßŸÑŸâ"]);

    function buildIndex(rows){
      return rows.map((r,i)=>({
        id:i,
        raw:r,
        tokens:{
          title:toks(r.title),author:toks(r.author),summary:toks(r.summary),
          content:toks(r.content||""),publisher:toks(r.publisher)
        },
        n:{
          title:norm(r.title),summary:norm(r.summary),content:norm(r.content||""),
          all: norm([r.title,r.author,r.summary,r.content,r.publisher,r.year].join(" "))
        }
      }));
    }

    function score(qT,rec){
      let s=0;
      const y=qT.find(t=>/^\d{4}$/.test(t));
      if(y && String(rec.raw.year||"")===y) s+=6;

      for(const f of ["title","author","summary","content","publisher"]){
        const w=WEIGHTS[f], F=rec.tokens[f]||[]; if(!F.length) continue;
        let h=0;
        for(const qt of qT){
          if(STOP.has(qt)) continue;
          if(F.includes(qt)) h+=1;
          else if(qt.length>=3 && F.some(t=>t.startsWith(qt))) h+=0.6;
        }
        if(f==="title" && h>0) h*=1.2;
        s += h*w;
      }

      const phrase=qT.join(" ");
      if(phrase && rec.n.title.includes(phrase)) s+=2.5;
      if(phrase && rec.n.summary.includes(phrase)) s+=1.0;
      if(phrase && rec.n.content.includes(phrase)) s+=1.0;

      // Arabic-friendly substring fallback for short tokens
      for (const qt of qT) {
        if (qt.length >= 2) {
          if (rec.n.title.includes(qt) || rec.n.summary.includes(qt) || (rec.n.content||"").includes(qt)) {
            s += 0.8;
          }
        }
      }
      return s;
    }

    // NEW: brute-force fallback if ranked search returns nothing
    function fallbackScan(idx, q, limit){
      const nq = norm(q);
      if (!nq) return [];
      const terms = nq.split(/\s+/).filter(Boolean);
      const out = [];
      for (const rec of idx){
        const hay = rec.n.all;
        // AND-match all terms as substrings
        if (terms.every(t => hay.includes(t))){
          out.push({sc:1, rec});
          if (out.length >= (limit||BOT_CFG.MAX_RESULTS)) break;
        }
      }
      return out;
    }

    function search(idx,q,lim){
      q=(q||"").trim(); if(q.length<BOT_CFG.MIN_QUERY_LEN) return [];
      const aF=/author:\s*"(.*?)"/i.exec(q)?.[1] || /author:\s*([^\s]+)/i.exec(q)?.[1];
      const yF=/year:\s*(\d{4})/i.exec(q)?.[1];
      const cleaned=q.replace(/author:\s*".*?"/ig,"").replace(/author:\s*[^\s]+/ig,"").replace(/year:\s*\d{4}/ig,"");
      const qT=toks(cleaned);
      const out=[];
      for(const rec of idx){
        if(aF && !norm(rec.raw.author).includes(norm(aF))) continue;
        if(yF && String(rec.raw.year||"")!==String(yF)) continue;
        const sc=score(qT,rec); if(sc>0) out.push({sc,rec});
      }
      out.sort((a,b)=>b.sc-a.sc);
      if (out.length===0){ return fallbackScan(idx, cleaned, lim); } // << robust Arabic fallback
      return out.slice(0, lim??BOT_CFG.MAX_RESULTS);
    }

    function setStatus(msg, err){ const el=document.getElementById("status");
      if(!el) return; el.className = err ? "row error" : "row"; el.textContent = msg; }

    function kohaURL(title){
      return `${BOT_CFG.KOHA_OPAC_BASE}/cgi-bin/koha/opac-search.pl?q=${encodeURIComponent(`ti="${title}"`)}`;
    }
    function render(items){
      const list=document.createElement("div");
      if(!items.length){ list.innerHTML=`<div class="row">No results found.</div>`; return list; }
      for(const {rec} of items){
        const r=rec.raw;
        const url = r.url && /^https?:\/\//i.test(r.url) ? r.url : kohaURL(r.title||"");
        const pub = [r.publisher, r.year].filter(Boolean).join(" ‚Ä¢ ");
        const div=document.createElement("div"); div.className="row";
        div.dir = isArabic(r.title||r.summary||r.content) ? "rtl" : "ltr";
        div.innerHTML=`
          <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;">
            <b style="font-size:15px;line-height:1.3">${(r.title||"").replace(/</g,"&lt;")}</b>
            <a class="btn" href="${url}" target="_blank" rel="noopener">Open record</a>
          </div>
          ${r.author? `<div class="meta">${isArabic(r.author)?"ÿßŸÑŸÖÿ§ŸÑŸÅ: ":"Author: "}${r.author}</div>` : ""}
          ${pub? `<div class="meta">${pub}</div>` : ""}
          ${r.summary? `<div style="margin-top:6px">${r.summary.length>360? r.summary.slice(0,357)+"‚Ä¶" : r.summary}</div>` : ""}
          ${r.content? `<div style="margin-top:6px;opacity:.9">${r.content.length>360? r.content.slice(0,357)+"‚Ä¶" : r.content}</div>` : ""}
        `;
        list.appendChild(div);
      }
      return list;
    }

    /* ===== Load ODS, map your columns (EN + AR), index ===== */
    let INDEX=[];
    fetch(BOT_CFG.DATA_URL,{cache:"reload"})
      .then(r => { if(!r.ok) throw new Error("HTTP "+r.status); return r.arrayBuffer(); })
      .then(buf => {
        const wb = XLSX.read(buf,{type:"array"});
        const ws = wb.Sheets["catalog"] || wb.Sheets[wb.SheetNames[0]];
        if(!ws) throw new Error("No sheets in ODS");
        const raw = XLSX.utils.sheet_to_json(ws,{defval:"",raw:false});

        const records = raw.map(row=>{
          const k = {};
          for (const [h,v] of Object.entries(row)) k[String(h).trim().toLowerCase()] = v;

          // Your columns + Arabic variants
          const title  = k["full title"] ?? k["ÿßŸÑÿπŸÜŸàÿßŸÜ"] ?? k.title ?? "";
          const author = k["author"] ?? k["ÿßŸÑŸÖÿ§ŸÑŸÅ"] ?? k["ÿßŸÑŸÖÿ§ŸÑŸÅŸàŸÜ"] ?? "";
          const summary= k["abstract"] ?? k["ÿßŸÑŸÖŸÑÿÆÿµ"] ?? "";
          const content= k["content"] ?? k["ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ"] ?? "";
          const pubdat = k["publications data"] ?? k["ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±"] ?? "";
          const url    = k["book_url"] ?? k["book url"] ?? k["ÿ±ÿßÿ®ÿ∑_ÿßŸÑŸÉÿ™ÿßÿ®"] ?? k.url ?? "";

          const yearMatch = String(pubdat).match(/(\d{4})/);
          const year  = yearMatch ? yearMatch[1] : "";
          const publisher = String(pubdat || "")
            .replace(/\b\d{4}\b/g,"")
            .replace(/\s*[.,;|-]\s*$/,"")
            .trim();

          return { title, author, summary, content, publisher, year, url };
        });

        INDEX = buildIndex(records);
        setStatus(`Loaded ${records.length} records`);
        const sample = render(records.slice(0,3).map((r,i)=>({rec:{raw:r},sc:1})));
        B.appendChild(sample);
      })
      .catch(err => { console.error(err); setStatus("Chatbot init failed: "+err.message, true); });

    // search handlers
    GO.onclick = () => {
      const q = Q.value.trim(); if(!q) return;
      const res = search(INDEX, q, BOT_CFG.MAX_RESULTS);
      while (B.children.length > 1) B.removeChild(B.lastChild); // keep status/hint
      B.appendChild(render(res));
    };
    Q.onkeydown = (e) => { if(e.key==="Enter") GO.click(); };
  })();
  </script>
</body>
</html>
