<!DOCTYPE html>
<html lang="ar" dir="auto">
<meta charset="UTF-8">
<title>CSV Diagnostic (Semicolon + Arabic)</title>
<style>
  body{font-family:system-ui,Segoe UI,Arial;padding:2rem}
  .box{max-width:800px;margin:auto}
  .log{white-space:pre-wrap;background:#f6f9fc;border:1px solid #e7edf4;border-radius:8px;padding:10px}
  input[type="file"]{display:none}
  label{background:#BF9849;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  table{border-collapse:collapse;margin-top:12px;width:100%}
  td,th{border:1px solid #ddd;padding:6px}
</style>
<div class="box">
  <h2>CSV Diagnostic</h2>
  <p>Click the button and choose <code>opac-export.csv</code> from your computer.</p>
  <label for="file">Load CSV file</label>
  <input id="file" type="file" accept=".csv,text/csv">
  <div id="out" class="log">Waiting…</div>
  <div id="table"></div>
</div>
<script>
// --- encoding fixer ---
function decodeBest(buf){
  const candidates = ["utf-8","windows-1256","windows-1252","iso-8859-6"];
  const decs = candidates.map(enc=>{
    try{ return [enc, new TextDecoder(enc,{fatal:false}).decode(buf)] }catch{ return null }
  }).filter(Boolean);
  const score = s=>{
    const arab = (s.match(/[\u0600-\u06FF]/g)||[]).length;
    const moj  = (s.match(/[ØÙÃÂ]/g)||[]).length + ((s.match(/[ØÙÃÂ]{2,}/g)||[]).length*10);
    const repl = (s.match(/\uFFFD/g)||[]).length*5;
    return arab - moj - repl;
  };
  let best=decs[0], bestScore=-1e9;
  for(const d of decs){ const sc=score(d[1]); if(sc>bestScore){best=d;bestScore=sc;} }
  return {encoding:best[0], text:best[1]};
}
// --- semicolon CSV parser with quotes/newlines ---
function parseCSV(text){
  const DELIM=';';
  const rows=[]; let field="", row=[], inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i];
    if(inQ){
      if(ch=='"'){ if(i+1<text.length && text[i+1]=='"'){ field+='"'; i++; } else inQ=false; }
      else field+=ch;
    }else{
      if(ch=='"') inQ=true;
      else if(ch==DELIM){ row.push(field); field=""; }
      else if(ch=='\n'){ row.push(field); rows.push(row); row=[]; field=""; }
      else field+=ch;
    }
  }
  row.push(field); if(row.length && (row.length>1 || row[0]!=="" )) rows.push(row);
  const headers = rows.shift()||[];
  const out = rows.map(r=>{
    const o={}; for(let i=0;i<headers.length;i++) o[headers[i]] = (r[i]||"").trim(); return o;
  });
  return {headers, rows:out};
}
const OUT = document.getElementById('out');
const TBL = document.getElementById('table');
document.getElementById('file').onchange = async e=>{
  const f=e.target.files?.[0]; if(!f){OUT.textContent="No file.";return;}
  const buf = await f.arrayBuffer();
  const {encoding, text} = decodeBest(buf);
  const parsed = parseCSV(text.replace(/\r\n|\r/g,"\n"));
  OUT.textContent = `Loaded ${parsed.rows.length} rows • Detected encoding: ${encoding}\nHeaders: ${parsed.headers.join(' | ')}`;
  // show first 3 rows
  const head = parsed.headers;
  const rows = parsed.rows.slice(0,3);
  let html = '<table><thead><tr>'+head.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody>';
  for(const r of rows){
    html += '<tr>'+head.map(h=>`<td>${(r[h]||'').replace(/</g,'&lt;')}</td>`).join('')+'</tr>';
  }
  html += '</tbody></table>';
  TBL.innerHTML = html;
};
</script>
